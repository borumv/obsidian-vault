---
created: Sunday 30th April 2023 13:21
Last modified: Sunday 30th April 2023 13:20
Aliases: кадр
Tags: programming
---

Элемент [[Java Memory Model]] который хранится в [[Stack в Java memory|стэке]].
Фрэйм используется для хранения данных  частичных реузльтатов, а также для динамического связывания, возврата значений для вызываемых методов и отправки исключений.
Каждый раз при вызове метода создаётся *новый фрэйм*. 
Какждый фрэйм содержит в себе:
1. *Массив локальных переменных*
одержит параметры метода и его локальные переменные, размер массива определяется на этапе компиляции и предоставляется вместе с кодом текущего метода. Для хранения значений типа double и long резервируется пара ячеек массива, все остальные примитивные типы помещаются в одной. Индексация ячеек начинается с 0, при этом при вызове метода объекта в переменной 0 содержится ссылка на сам объект (this). Параметры метода записываются в начало массива в том порядке, в каком они были объявлены.
2. Собственный стэк операндов
вляется структурой для внутреннего использования JVM. При создании фрейма он пуст и, по сути, выполняет роль регистровой памяти. Есть операторы, которые загружают данные в стек операндов, есть операторы, выгружающие из стека в массив локальных переменных, все вычисления производятся над элементами стека и результат записывается в него же: всё точно так же, как это происходит в ассемблере на реальном процессоре, только в процессоре это обусловлено тем, что железная плата может выполнить операцию только над данными, которыми она лично располагает, поэтому кто-то должен для неё сходить в оперативную память и взять оттуда значения, а после сохранить туда результат операции.

В качестве иллюстрации работы всей системы удобно взять простой пример калькулятора.
![[Pasted image 20230430134432.png]]
После компиляции этого класса и обработки его командой **javap -c** можно почитать байт код интересующего нас метода _add_.
![[Pasted image 20230430134508.png]]

**_iload_0_** кладёт _int_ из ячейки 0 массива локальных переменных в стек операндов
**_iload_1_** делает то же самое с ячейкой под индексом 1
**_iadd_** снимает со стека операндов два числа типа _int_, складывает их и кладёт результат в стек операндов
**_istore_2_** записывает в массив локальных переменных под индексом 2 то, что находится в стеке операндов
**_iload_2_** кладёт в стек операндов содержимое ячейки 2 массива локальных переменных
**_ireturn_** снимает со стека операндов текущего фрейма верхнее значение и кладет его в стек операндов метода, вызвавшего текущий.
Мы видим, что, как и java код, байт-код избыточен, переменная _res_ не нужна и приводит лишь к двум излишним инструкциям байт-кода. Странно, что JVM его не оптимизировала, у меня были большие надежды.
Давайте вызовем наш метод: _Calculator.add(4, 7);_

Все манипуляции с текущим фреймом метода _add_ приведены далее на рисунке.

1. пул констант времени выполнения
