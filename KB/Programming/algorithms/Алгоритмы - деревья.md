---
tags: algorithms, решение_задачи
---
**МЕНЕДЖЕР ПАМЯТИ**
- У нас есть заранее **неизвестное** количество структур с двумя ссылками на другие структуры
- Мы знаем заранее, какое **максимальное** количество структур может сущетсвовать одновременно
- Хотим научиться **выделять и освбождать** память

**Что мы сделаем?**
Создадим 3 массива
1) **Ключ** - что будет содержательно хранитсья в элементе
2) **Левый сын** - просто числовой массив (хранит номер **следующей** ячейки памяти), фактически, таким образом, мы организовываем **односвязанный список**
3) **Правый сын** - просто числовой массив

Посмотрим, что произойдёт, когда мы **выделим** какую-то память. По-сути, мы должны сказать в какое место **можно положить** что-то содержательное. Мы, после выделения, должны сделать так, чтобы первый свободный элемент показывал на действительно первый свободный (свободный элемент ищется по **индексу первого свободного элемента**):
![[Pasted image 20220828184508.png]]
![[Pasted image 20220828185104.png]]
А теперь **освободим** элемент  с индексом **0**. В таком случае, мы в левого сына  индекса закидываем индекс **первого свободного** до освобождения. А потом, первым свободным становится элемент с индексом **0**
![[Pasted image 20220828185235.png]]

```java
  
public class Memory {  
  
    int[][] memory;  
    int indexFreeElement;  
  
    public Memory(int sizeMemory) {  
        setMemory(new int[sizeMemory][3]);  
        for (int i = 0; i < sizeMemory; i++) {  
            this.memory[i][0] = 0;  
            this.memory[i][1] = i + 1;  
            this.memory[i][2] = 0;  
        }  
    }  
  
    public int newNode(){  
        setIndexFreeElement(this.memory[indexFreeElement][1]);  
        return this.indexFreeElement;  
    }  
    public void delNode(int index){  
        this.memory[index][1] = getIndexFreeElement();  
        setIndexFreeElement(index);  
    }  
  
  
    public int[][] getMemory() {  
        return memory;  
    }  
  
    public int getIndexFreeElement() {  
        return indexFreeElement;  
    }  
  
    public void setMemory(int[][] memory) {  
        this.memory = memory;  
    }  
  
    public void setIndexFreeElement(int indexFreeElement) {  
        this.indexFreeElement = indexFreeElement;  
    }  
}
```


**НЕ БИНАРНЫЕ ДЕРЕВЬЯ**
- У узлов дерева может быть и больше двух сыновей, тогда их нужно хранить **списком**
- **Примеры** -  дерево каталогов и файлов, html-документы (DOM- дерево), дерево классов в программе и т.д.
- Обходим так же как бинарное, просто запуская рекурсивную функцию для всех детей

**СЕРИАЛИЗАЦИЯ ДЕРЕВА ХАФФМАНА**
- Алгоритм Хаффмана позволаяет сопоставить **более часто встречающимся** символам более **короткий код**
- Каждый раз берём два самых редко встречающихся символа и объединяем их в один узел
- Строим бинарное дерево, кладем буквы в листья. Переход в левого сына кодируется числом 0, в правого, а код символа - это все ребра на пути от корня до листа
- В притмере буква"а" встречается 4 раза, "б" - 3 раза, а "в" и "г" по одному разу

![[Pasted image 20220830101546.png]]

**КАК СОХРАНИТЬ СТРУКТУРУ ДЕРЕВА В ВИДЕ СТРОКИ?**
- **L** - в левого ребенка, **R** - в правого, **U** - в предка
	- **LURLLURUURUU**
- **D** - в наиболее левого непосещенного ребенка (детей всегда либо два, либо ноль)
	- **DUDDDUDUUDUU**
- Теперь **U** означает, что мы поднимаемся вверх до тех пор, пока приходим из правого ребенка. Если пришли в вершину из левого ребенка - сразу пойдем в правого
	- **DUDDUU**

>[INFO]
>**Восстановление дерева по записи**
>**D** - в наиболее левого непосещенного ребенка (детей всегда либо два, либо ноль)
>**U** - поднимаемся вверх до тех пор, пока приходим из правого ребенка. Если пришли в вершину из левого ребенка -  сразу пойдем в правого
>**DDUUDU**
>![[Pasted image 20220830103413.png]]
>