---
created: Wednesday 21st December 2022 10:24
Last modified: Wednesday 21st December 2022 10:24
Aliases: Ñ€ÐµÑˆÐµÑ‚Ð¾ ÑÑ€Ð°Ñ‚Ð¾ÑÑ„ÐµÐ½Ð°
Tags: ÑÑ€Ð°Ñ‚Ð¾ÑÑ„ÐµÐ½  algorithms
---

# [[Ð ÐµÑˆÐµÑ‚Ð¾ Ð­Ñ€Ð°Ñ‚Ð¾ÑÑ„ÐµÐ½Ð°]]

Parent: [[ðŸ“™MOC-ALGORITHMS]]

Ð ÐµÑˆÐµÑ‚Ð¾ Ð­Ñ€Ð°Ñ‚Ð¾ÑÑ„ÐµÐ½Ð° Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÐµÑ‚ Ð½Ð°Ð¹Ñ‚Ð¸ Ð²ÑÐµ **Ð¿Ñ€Ð¾ÑÑ‚Ñ‹Ðµ Ñ‡Ð¸ÑÐ»Ð°** Ð² Ð¾Ñ‚Ñ€ÐµÐ·ÐºÐµ Ð¾Ñ‚ **1** Ð´Ð¾ **n**

>ÐœÑ‹ Ð¿Ñ€Ð¾Ñ…Ð¾Ð´Ð¸Ð¼ Ð¿Ð¾ Ð¼Ð°ÑÑÐ¸Ð²Ñƒ Ñ‡Ð¸ÑÐµÐ» Ð¸ Ð²Ñ‹Ñ‡Ñ‘Ñ€ÐºÐ¸Ð²Ð°ÐµÐ¼ Ð²ÑÐµ Ñ‡Ð¸ÑÐ»Ð°, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ Ð´ÐµÐ»ÑÑ‚ÑÑ Ð½Ð° 2 Ð¸ 3, ÐºÑ€Ð¾Ð¼Ðµ ÑÐ°Ð¼Ð¸Ñ… 2 Ð¸ 3
 **ÐÑÐ¸Ð¼Ð¿Ñ‚Ð¾Ñ‚Ð¸ÐºÐ°**: O(n * log log n)

*ÐžÐ¿Ñ‚Ð¸Ð¼Ð¸Ð·Ð°Ñ†Ð¸Ð¸:*
1) ÐÐµÑ‚ ÑÐ¼Ñ‹ÑÐ»Ð° Ð¸Ð´Ñ‚Ð¸ Ð¿Ð¾ Ð²ÑÐµÐ¼Ñƒ Ð¼Ð°ÑÑÐ¸Ð²Ñƒ, Ð° Ð´Ð¾ÑÑ‚Ð°Ñ‚Ð¾Ñ‡Ð½Ð¾ Ð¿Ñ€Ð¾Ð²ÐµÑ€Ð¸Ñ‚ÑŒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¸Ð´Ñ‚Ð¸ Ð´Ð¾ **ÐºÐ¾Ñ€Ð½Ñ Ð¾Ñ‚ n**. *Ð˜ Ñ‚Ð¾, ÐºÐ°Ðº Ñ Ð¿Ð¾Ð½ÑÐ», 2 Ð¸ 3 Ð¿Ð¾ÐºÑ€Ñ‹Ð²Ð°ÑŽÑ‚ Ð²ÑÐµ Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ñ‹ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ*
2) ÐœÐ¾Ð¶Ð½Ð¾ ÑƒÐ±Ñ€Ð°Ñ‚ÑŒ Ð²ÑÐµ Ñ‡Ñ‘Ñ‚Ð½Ñ‹Ðµ. Ð¢.Ðº. Ð²ÑÐµ Ñ‡Ñ‘Ñ‚Ð½Ñ‹Ðµ, ÐºÑ€Ð¾Ð¼Ðµ 2-Ñ… - **Ð½Ðµ Ð¿Ñ€Ð¾ÑÑ‚Ñ‹Ðµ**
3) ÐœÐ¾Ð¶Ð½Ð¾ Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ Ð¼Ð°ÑÑÐ¸Ð² Ð½Ðµ **boolean** Ñ‚Ð¸Ð¿Ð° Ð° **n** Ð±Ð°Ð¹Ñ‚. Ð­Ñ‚Ð¾ ÑƒÐ¼ÐµÐ½ÑŒÑˆÐ¸Ñ‚ Ð¿Ð¾Ñ‚Ñ€ÐµÐ±Ð»ÐµÐ½Ð¸Ðµ Ð¿Ð°Ð¼ÑÑ‚Ð¸ ~ Ð² 8 Ñ€Ð°Ð·. Ð­Ñ‚Ð¾Ñ‚ Ð¿Ð¾Ð´Ñ…Ð¾Ð´ Ð½Ð°Ð·Ñ‹Ð²Ð°ÐµÑ‚ÑÑ [Ð±Ð¸Ñ‚Ð¾Ð²Ñ‹Ð¼ ÑÐ¶Ð°Ñ‚Ð¸ÐµÐ¼](Ð‘Ð¸Ñ‚Ð¾Ð²Ð¾Ðµ ÑÐ¶Ð°Ñ‚Ð¸Ðµ)


**Ð—Ð°Ð´Ð°Ñ‡Ð°:** Ð½Ð°Ð¹Ñ‚Ð¸ Ð²ÑÐµ Ð¿Ñ€Ð¾ÑÑ‚Ñ‹Ðµ Ñ‡Ð¸ÑÐ»Ð° Ð² Ð¿Ñ€Ð¾Ð¼ÐµÐ¶ÑƒÑ‚ÐºÐµ Ð´Ð¾ **n**

> [!success] Solution
>
```java
public static void search(int numbers){  
    boolean[] marks = new boolean[numbers];  
    Arrays.fill(marks, true);  
    List<Integer> primes = new ArrayList<>();  
    primes.add(2);  
    for (int i = 3; i * i < numbers ; i += 2) {  
  
        if(marks[i]){  
            for (int j = i * i; j < numbers; j+=i) {  
                marks[j] = false;  
            }  
        }  
    }  
    for (int i = 3; i < numbers; i+=2) {  
        if(marks[i]) {  
            primes.add(i);  
        }  
    }  
    for (Integer prime : primes) {  
        System.out.println(prime);  
    }  
}
```
![[138. Copy List with Random Pointer.jpg]]
An intuitive solution is to keep a hash table for each node in the list, via which we just need to iterate the list in 2 rounds respectively to create nodes and assign the values for their random pointers. As a result, the space complexity of this solution is `O(N)`, although with a linear time complexity.

_Note: if we do not consider the space reversed for the output, then we could say that the algorithm does not consume any additional memory during the processing, i.e. O(1) space complexity_

As an optimised solution, we could reduce the space complexity into constant. _**The idea is to associate the original node with its copy node in a single linked list. In this way, we don't need extra space to keep track of the new nodes.**_

The algorithm is composed of the follow three steps which are also 3 iteration rounds.

1. Iterate the original list and duplicate each node. The duplicate  
    of each node follows its original immediately.
2. Iterate the new list and assign the random pointer for each  
    duplicated node.
3. Restore the original list and extract the duplicated nodes.

The algorithm is implemented as follows:
see also:[]
