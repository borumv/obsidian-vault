> - Пусть необходимо отсортировать массив из **N** целых чисел, каждое от **0** до **K**
> -  Обычная сортировка займёт **О(NlogN)**
> - Будем считать количество вхождений каждого числа, а затем выводить каждое число столько раз, сколько оно встречалось. Это займёт **О(N + K)** и **O(K)** дополнительной памяти
> - Интервал значений можно сдвинуть чтобы он был не от 0 до к, а от минимального до максимального значения в массиве

_Сортировка подсчётом используется в широком классе задач где значений не так уж много_

Например, есть задач отсортировать оценки по предметам человека в последовательности возрастания.

> [!NOTE]
> > Дано два числа **X** и **Y** без ведущих нулей
> > Необходимо проверить, можно ли получить первое из второго перестановкой цифр 
> 
> 
> ***Решение***
> > Посчитаем количество вхождений каждой цифры в кождое из чисел и сравним. Цифры будем постепенно добывать из числа справа с помощью **% 10 и / 10**

```java
**public class DigitPermulation {  
    public static void main(String[] args) {  
        int a = 213313;  
        int b = 231236;  
        System.out.println(digitPermulate(a, b));  
        System.out.println(digitPermulate(123,321));  
    }  
  
    private static boolean digitPermulate(int i, int j) {  
        int[] massiveI = createMassive(i);  
        int[] massiveJ = createMassive(j);  
        for (int k = 0; k <= 9; k++) {  
            if (massiveJ[k] != massiveI[k]){  
                return false;  
            }  
        }  
        return true;  
    }  
    private static int[] createMassive(int a){  
        int[] massive = new int[10];  
        Arrays.fill(massive, 0);  
        while (a > 0){  
            massive[a % 10] +=1;  
            a /= 10;  
        }  
        return massive;  
    }  
  
}**
```