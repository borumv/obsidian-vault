https://habr.com/ru/articles/685518/

Проблемы:
- Java дает _as-if-serial_ гарантию только для единственного треда в изоляции. Это означает, что в многопоточной программе при работе с shared данными *мы можем не увидеть записи* там, где полагаемся на порядок выполнения действий в коде другого треда.
- Процессор также дает гарантию только *для единственного ядра в изоляции*
- *Cache Coherence* действительно гарантирует чтение актуальных значений, но пропагация записи происходит не мгновенно, а с некоторой задержкой

```java
public class MemoryReorderingExample {
   private int x;
   private int y;

   public void T1() {
      x = 1;
      int r1 = y;
   }

   public void T2() {
      y = 1;
      int r2 = x;
   }
}
```

С первого взгляда, этот код не сможет присвоить значение 0 переменным `r1` и `r2`, т.к. определён порядок, где чтение происходит в первом из каждых потоков. 
Однако, хоть это и может показаться странным, в данной программе мы вполне можем наблюдать результат чтения `(r1, r2) = (0, 0)`. А причины следующие: 

1. _Instructions reordering_. Оба треда могли поменять местами инструкции записи и чтения, так как эти действия никак не связаны
2. _Visibility_. Даже если переупорядочивания не было, записи могут быть просто не видны другому треду из-за оптимизаций компилятора или задержки при *пропагации* записи на уровне кеша
3. 