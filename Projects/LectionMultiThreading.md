- Пулы потоков
- Атомик-переменные
- CompletableFuture

**ПП**
--

```md
# Проблема
Есть явные способы создания потоков (Через наследования от класса Thread или имплементации Runnable)
Например, есть какой-то веб сервис, в который постоянно идут разные клиенты. Во-первых, мы не можем обсчитывать клиентов последовательно, то через пару минут клиент получит информацию примерно через неделю :D

Если мы для каждого обращения будет создавать отдельный поток, то мы можем столкнуться с проблемами:
1) Что у нас очень много Thread-ов одновременно запущенных.
2) На запуск Thread-a тратится какое-то время
3) Одни запрос -> Один Thread -> за очень маленькое время накапливается куча очень маленьких Threadov

Для решения существует несколько классов и интерфейсов, которые некоторые называют Executor Framework in Java.
```

![[Pasted image 20220613191221.png]]


Основные интерфейсы: Executor, ExecutorService и фабрика Executors. Объекты, которые реализуют интерфейс Executor, могут выполнять runnable-задачу. 
**Интерфейс Executor** имеет один метод void execute(Runnable command). После вызова этого метода и передачи задачи на выполнение задача в будущем будет выполнена асинхронно. Также этот интерфейс разделяет, кто будет выполнять задачу и что будет выполняться, — в отличии от класса Thread.

**Интерфейс ExecutorService** наследуется от интерфейса Executor и предоставляет возможности для выполнения заданий Callable, для прерывания выполняемой задачи и завершения работы пула потоков. Для выполнения задач, которые возвращают результат, существует метод **submit()**, возвращающий объект, который реализует интерфейс **Future<T>.** С помощью этого объекта можно узнать, есть ли результат, вызовом метода **isDone()**. С помощью метода **get() **можно получить результат выполнения задачи, если он есть. Также можно отменить задание на выполнение при помощи метода **cancel()**.

#### Future
> [!INFO]
>  - Это обёртка результата, доступного в будущем
> - Получение значения требует проверки исключений
> 	 - ExecutionException = эксепшн-обёртка, в который помещаются ошибки, выполненные в блоке кода.
> - Исполняется в каком-то потоке и блокирует какой-то (другой) поток
> - Можно проверить, доступно ли уже значение (isDone)
> - Можно отменить вычисление


**Класс Executors** — утилитный клас, как например, класс Collections. Класс Executors создает классы, которые реализуют интерфейсы Executor и ExecutorService. Основные реализации пула потоков, т. е. реализации интерфейсов Executor и ExecutorServcie:


Для завершения работы пула потоков у интерфейса ExecutorService есть несколько методов: **shutdown()**, **shutdownNow() **и **awaitTermination(long timeout, [TimeUnit](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/TimeUnit.html) unit)**.

После вызова метода **shutdown()** пул потоков продолжит работу, но при попытке передать на выполнение новые задачи они будут отклонены, и будет сгенерирован RejectedExecutionException.

Метод **shutdownNow()** не запускает задачи, которые были уже установлены на выполнение, и пытается завершить уже запущенные.

Метод **awaitTermination(long timeout, [TimeUnit](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/TimeUnit.html) unit) **блокирует поток, который вызвал этот метод, пока все задачи не выполнят работу, или пока не истечет таймаут, который передан при вызове метода, или пока текущий ожидающий поток не будет прерван. В общем, пока какое-то из этих условий не выполнится первым.

*ThreadPoolExecutor*
	- corePoolSize - начальное число потоков
	- maximumPoolSize - максимальное число потоков
	- workQueue - очередь задач

Executor.newCachedThreadPool
	- corePoolSize - 0
	- maximumPoolSize - Integer.MAX_VALUE
	- workQueue - SynchronousQueue (*очередь в которой вообще нет capacity*)
	Проблема: Количество потоков может расти до бесконечности

Executor.newFixedThreadPool
	- corePoolSize - n
	- maximumPoolSize - n
	- workQueue - LinkedBlockingQueue(*бесконечное капасити*)
	Проблема:
	 - Количество элементов в очереди может расти до бесконечности
	Есть ещё одна проблема

*Исходя из этого, можно создать свой ThreadPool
newFixedBoundedThreadPool
	- corePoolSize - n
	- maximumPoolSize - n
	- workQueue - ArrayBlockingQueue
	Проблема: Необходимо правильно задать максимальное количество задач в очереди и правильно написать обработчик ошибок*


> [!Warning]
> Проблема с Executor.newFixedThreadPool и не только:
> - Все задачи помещаются в LinkedBlockingQueue
> - Несколько потоков пытаются достать задачи одновременно 
> - Для предотвращения гонок, очередь защищена ReentrantLock
> - ...который основан на AbstractQueuedSynchronizer
> - ...который вызывает park в случае с contention
> - ...который вызывает pthread_cont_wait
> - ...который переводит поток в состояние TASK_INTERRUPTIBLE
> - **В результате**: время получения задачи из очереди может оказаться значительной

**FJP**
---
FJP - это реализация ExecutorService.
Для реализации воркстилинга в FJP используется двухсторонний дек, с головы берёт работу 1 поток, а с хвоста поток, который освободился -> освобождается вопрос о конкурентности за задачи.
![[Pasted image 20220613103727.png]]

Для вставки задач в очередь используется метод `push()`, а владелец очереди захватывает задачу, вызывая метод `pop()`. Таким образом, владельцем очереди сама очередь используется в качестве стека. В рамках этого используется метод [[LIFO]]
Основная причина  —  повышение производительности. Всегда, выбирая самую последнюю задачу, мы **увеличиваем шансы на то, что ресурсы задачи все еще будут распределены в кэшах процессора**, а это значительно повысит производительность. Это обычно называют [локальностью ссылок](https://en.wikipedia.org/wiki/Locality_of_reference).
Ворк-стилинг будет происходит с помощью метода `poll()` 
![[Pasted image 20220613104440.png]]

> [!INFO]
> Методы `push` и `pop` вызываются только владельцем очереди, а метод `poll` вызывается только процессором, пытающимся “украсть” работу у другого процессора.

_ForkJoinTask_ является базовым типом для задач, выполняемых внутри _ForkJoinPool._ На практике следует расширить один из двух его подклассов: _RecursiveAction_ для _void_ задач и _RecursiveTask_ для задач, возвращающих значение. У них обоих есть абстрактный метод _compute ()_ , в котором определена логика задачи.


> [!INFO]
> **Linux runqueue**
> - Linux использует по очереди на каждое ядро
> - Периодически задачи балансируют между ядрами

FJP реализует подход [[work-stealing]], соотвественно поток с пустой очередью задач забирает задачи из очередей других потоков.
В реальной жизни задачи позиционирования FJP "разделяй и властвуй" встречаются не так часто.
До определённой версии [[📙MOC-JAVA]] для внешних задач использовалась единая submission queue у которой был единый лок и у которой были те же самые проблемы, что и у обычных ThreadPool.
Но, как только появилась Java 8:
- Появился FJP.commonPool, тредпулл который используется по дефолту
- ...который используется как default executor для CompletionStage
- Это внешние, нерекурсивные задачи
- Теперь количество submission queue равно количеству тредов

FJP использует несколько очередей и механизм work-stealing для борьбы с contention


#### CompletableFuture

  
**CompletableFuture** используется для асинхронного программирования в Java. Асинхронное программирование — это средство написания неблокирующего кода путём выполнения задачи в отдельном, отличном от главного, потоке, а также уведомление главного потока о ходе выполнения, завершении или сбое.
  
CompletableFuture это расширение [Future API](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html), представленного в Java 5.  
  
Future используется как ссылка на результат асинхронной задачи. В нём есть метод isDone() для проверки, завершилась ли задача или нет, а также метод get() для получения результата после его завершения.  
  
Future API был хорошим шагом на пути к асинхронному программированию, но ему не хватало некоторых важных и полезных функций.

> Проблемы с которыми не справляется Future
>  - Нельзя выполнять дальнейшие действия над результатом Future без блокирования.
> 	 - Future не уведомляет о своём завершении. В нём есть метод get(), который **блокирует** поток до тех пор, пока результат не станет доступным.  Также в Future нельзя повесить функцию-колбэк, чтобы она срабатывала автоматически, как только станет доступен результат.
> - Невозможно выполнить множество Future один за другим
>     - Бывают случаи, когда требуется выполнить длительную операцию и после её завершения передать результат другой длительной операции и так далее.  Такой алгоритм асинхронной работы невозможен при использовании Future.
>  - Невозможно объединить несколько Future.
> 	 - Предположим, что у вас есть 10 различных задач во Future, которые вы хотите запустить параллельно, и как только все они завершатся, вызвать некоторую функцию. С Future вы не можете сделать и это.
>  - Нет обработки исключений.
> 	 - Future API не имеет механизма обработки исключений.

Создание CompletableFuture
```java
CompletableFuture.runAsync() \\ полезен для задач, которые ничего не возвращают
CompletableFuture.supplyAsync() \\Он принимает Supplier<T> и возвращает CompletableFuture<T>, где T это тип возвращаемого функцией-поставщиком
```
Если **нет приставки Async**, то задача выполняется в том же потоке.

CompletableFuture имплементит Future и [[java_CompletionStage]]
CompletionStage
apply(Funcntion<T,R> -> ComplitionStage<R>) - когда есть преобразование, combine какой-нибудьт и тд
accept(Consumer<T>) - когда к нам приходит какой-то результат, но мы не делаем никакую обработку
run(Runnable)

Наборы для произвольного графа вычислений:
1) Унарные методы
	-thenApply -thenAccept -thenRun
2-3) Бинарные мтоды
	OR - applyToEither, acceptEither, runAfterEither
	AND - thenCombine (reduce), thenAccecBoth, runAfterBoth


Методы, которые остались (т.е. не строятся из каких-либо ключевых слов):
-thenCompose (flatMap)
-handle/whenComplete
-exceptionally/exceptionallyCompose
-toCompletableFuture

Для набора:
- CompletableFuture<Object> anyOf(CompletableFuture<?> ... cfs) - когда послал много запросов к базе данных, кто первый получит результат, того и взяла.
- CompletableFuture<Void> allOf(CompletableFuture<?> ... cfs) - собирает результат всех 

> [!INFO]
> В какой ветке будут выполняться те или иные методы (thenApplyAsync, supplyAsync ...) зависит от того, в каком состоянии находится наш CompletableFuture - оно может быть уже закомпличено или ещё нет. 
> Если Мы не закомпличены, то мы **попадём в нитку Executor-a**, который мы указали (*по умолчанию - ForkJoinPool.CommonPool()*)
> А если мы закомпличены - то поток уже будет **текущим потоком исполнения**


**ABQ**
---

ArrayBLockingQueue является потокобезопасным аналогом (FIFO](FIFO)
...new ArrayBlockingWyeye<Integer>(10) 

queue.put(9) - добавление
queue.take() - взять элемент из очереди, будет ждать, если там ничего нет




